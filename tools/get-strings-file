#!/bin/env python3

import argparse
import csv
import io
import os
import re
import requests
import subprocess

QUESTS_PATH = os.path.join('eosclubhouse', 'quests')
CSV_PATH = os.path.join('data', 'quests_strings')
CSV_ALTERNATIVE_PATH = os.path.expanduser('~/.var/app/com.endlessm.Clubhouse' +
                                          '/data/quests/quests_strings')

URL_TEMPLATE = ('https://docs.google.com/spreadsheets/d/{key}/' +
                'gviz/tq?tqx=out:csv&sheet={sheet}&range={range}')
URL_PARAMS = {
    'key': '162yiw_kW3lgLEIUwBq3PgiZxWTtcVBUHqpZKUXtF8qY',
    'range': 'A:F'
}

ALL_SHEETS = ['Episode1', 'Episode2', 'Episode3', 'Episode4']

quest_codes = None


def get_quest_codes():
    global quest_codes
    if quest_codes is not None:
        return quest_codes

    quest_codes = set(['noquest'])
    for episode in os.listdir(QUESTS_PATH):
        episode_path = os.path.join(QUESTS_PATH, episode)
        if not os.path.isdir(episode_path):
            continue
        for filename in os.listdir(episode_path):
            if filename == '__init__.py' or filename.startswith('questset_'):
                continue
            code, _ext = os.path.splitext(filename)
            quest_codes.add(code)

    quest_codes = list(quest_codes)
    return quest_codes


def get_rows_from_sheet(sheet):
    url_params = URL_PARAMS.copy()
    url_params['sheet'] = sheet

    url = URL_TEMPLATE.format(**url_params)
    response = requests.get(url)
    response.raise_for_status()
    trimmed_text = re.sub(r'\n\s+$', '\n', response.text, 0, re.M)
    csv_file = io.StringIO(trimmed_text)
    return list(csv.reader(csv_file))


def _get_rows_for_quest(quest, rows):
    return (r for r in rows if r[0].startswith(quest.upper()))


def _write_csv_file(filename, rows):
    with open(filename, 'w') as out_file:
        writer = csv.writer(out_file)
        for r in rows:
            sfx_sound = r[-2] if r[-2].startswith('quests/') else ''
            bg_sound = r[-1] if r[-1].startswith('quests/') else ''
            r = r[:-2] + [sfx_sound, bg_sound]
            writer.writerow(r)


def write_quests(quests, rows, use_alternative_path=False):
    csv_path = CSV_PATH if not use_alternative_path else CSV_ALTERNATIVE_PATH
    remaining_rows = None
    if quests is None:
        quests = get_quest_codes()
        remaining_rows = {r[0]: r for r in rows}

    os.makedirs(csv_path, exist_ok=True)
    for quest in quests:
        quest_rows = list(_get_rows_for_quest(quest, rows))
        if not quest_rows:
            print('Quest "{}" has no rows to import.'.format(quest))
            continue

        if remaining_rows is not None:
            for r in quest_rows:
                del remaining_rows[r[0]]
        filename = os.path.join(csv_path, quest + '.csv')
        _write_csv_file(filename, quest_rows)

    if remaining_rows is not None:
        remaining_rows = list(remaining_rows.values())
        remaining_rows.sort()
        filename = os.path.join(csv_path, 'remaining.csv')
        _write_csv_file(filename, remaining_rows)


def _build_commit_message(sheets=None, quests=None):
    sheets_string = ', '.join(sheets or ['all'])
    quests_string = ', '.join(quests or ['all'])

    head = 'data: Update quests strings CSV'
    body = 'From sheets: {}.'.format(sheets_string)
    body += '\n\n'
    body += 'Quests requested for import: {}.'.format(quests_string)
    return head + '\n\n' + body


def make_commit(sheets, quests):
    message = _build_commit_message(sheets, quests)

    # Ensure we don't include previously added things in this commit
    subprocess.call(['git', 'reset', 'HEAD'])

    # Add any changes to the CSV file and commit them
    subprocess.call(['git', 'add', os.path.join(CSV_PATH, '*.csv')])
    subprocess.call(['git', 'commit', '--no-verify', '-m', message])


def main(sheets=None, quests=None, commit=False, use_alternative_path=False):
    sheets_to_import = sheets or ALL_SHEETS

    rows = []
    for sheet in sheets_to_import:
        rows.extend(get_rows_from_sheet(sheet))

    write_quests(quests, rows, use_alternative_path)

    if not commit or use_alternative_path:
        return
    make_commit(sheets, quests)


parser = argparse.ArgumentParser(description='Obtain the strings to be used in quest messages.')
parser.add_argument('--sheets', type=str,
                    metavar='SHEET',
                    nargs='+',
                    help=('Obtain strings from the specified sheets. ' +
                          'If this parameter is not passed, all known sheets will be imported.'))
parser.add_argument('--quests', type=str,
                    metavar='QUEST',
                    nargs='+',
                    help=('Get only the strings for the specified quests. ' +
                          'Strings that are not specific to any quest will only be obtained ' +
                          'if this parameter is not passed.'))
parser.add_argument('--commit', action='store_true',
                    help='Make a commit with the updated strings.')
parser.add_argument('--use-alternative-path', action='store_true',
                    help='Import the strings into the alternative path.')

args = parser.parse_args()
available_quests = get_quest_codes()

if args.quests is not None:
    bad_quests = set(args.quests) - set(available_quests)
    if bad_quests:
        parser.error(('The following quests are not available: {}.\n' +
                      'Available quests: {}').format(bad_quests, available_quests))

main(**vars(args))
